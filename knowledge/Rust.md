### 特徴
早いらしい、静的型付け言語
ガーベッジコレクションがない

### びっくりしたこと、感想
#### 変数をそのまま出力できないっぽい

#### stringキモすぎ
	&str→不変
	String→mutで宣言されていれば可変
	Stringの生成
	String::from("");
	"".to_string();

#### 変数の再宣言ができる（シャドウイング）
	メリットなんだ？

#### 数値型が柔軟
	i32とかf64とか
	ビットで決められる
	これもメモリ効率に関わるのかな
	できるだけ小さく領域を確保しておく、みたいな
#### タプルはそのまま出力できない
	println!("{:?}",tupple);
	で出力する
	配列、ベクタも同じ

#### タプル、配列、ベクタ
	タプルはどんな型でも入れられる。
	配列、ベクタは同じ型
	配列は要素数を指定するので変えられない
	ベクタは変えられる
	オブジェクトはないのか？
	それに当たるのがタプル？

#### メモリ管理
	テキスト領域　機械語、よくわからん
	静的領域　const、文字列リテラルなど中身が完全に固定のもの
	スタック領域　バイト数が決まっているもの。i32とか、タプルとか。確保するメモリ数が確定している
	ヒープ領域　動的に変わるもの。Stringとか、ベクタとか
	
	メモリ管理の課題
	→そもそもどこのメモリの話をしているのか？
	自身で
#### スタック領域
	LIFO
	最初に定義した変数からどんどん積み上がっていく。
	使われるたびに新しいものから消費されていいく。
	高速なアクセスが可能
#### ヒープ領域
	動的な領域、低速なアクセス
	ガーベッジコレクタで自動で削除してくれるのがJavaとかC#とか
	Cは自分で開放する必要があるのでメモリリークが起きる
	Rustはどちらでもないやりかたでメモリ管理している

### 学び
#### 構造体
structで宣言、classっぽいがちょっと違う?
classはnewして使うが、newしなくても使える
struct内には関数は定義できない
関数はimplに定義
implは単独では存在できないぽい
structで定義済のものをimpl
構造体のメソッドには、&self引数が必要
これがないと呼び出せない

&selfをつけない場合には型関連関数として識別される
これはインスタンス化が必要ない
構造体名 :: 関数名で呼び出せる
コンストラクタ定義とかに使う

コンストラクタを定義する場合にはnewという関数名で定義するのが一般的
```rust
fn main() {
    let rect = Rectangle {
        width: 10,
        height: 8,
    };

    let newRect = Rectangle::new(10, 8);
}
impl Rectangle {
    fn new(width: i32, height: i32) -> Self {
        Rectangle { width, height }
    }
}

struct Rectangle {
    width: i32,
    height: i32,
}
```
コンストラクタを通してインスタンス化するのと、直接インスタンス化するの何が違うんだ

#### トレイト
インターフェースみたいなもの
そもそもインターフェースの嬉しいことがわかってない

### わからないこと
#### 型推論
	constでは型推論ができない、letではできる
	どういうことか
	拡張機能のお陰で勝手に型が入るのでりかいできてないだけ？
	→constだと型を保管してくれない
	どういう違いがあるのか

#### &の役割
	&strとか、スライスのときにも使う
	&arr[..]

#### !の役割
	println!
	になっている

#### Option型の存在意義
	講座ではnullを扱わないための方策、みたいなことを言っていた
	ベクタのpopやgetの戻り値はOption型になっている
	値が取れた場合はSum()にラップされて取れる
	値がない場合はNoneが取れる
	結局Noneになるので同じでは？
	nullとして返ってくるのではなく、Optionという型でラップされていることに意味があるのか？

#### Char型を使うタイミング
	1文字だけ使いたいことある？

#### 文字列結合でプラス演算子を使うタイミング
	左オペランドがString型、右オペランドが文字列リテラル（文字列スライス）でなければならない
	不便すぎる

#### ダングリングポインタ
	参照関連、ライフタイムが切れた値を参照することがダングリングポインタなのか？

#### ライフタイムを明示的に書く理由
	tick Aみたいなやつ。どういうメリットがあるんだ

#### スマートポインタ
	どういうこと？
	RcとBox
	メモリサイズが確定しないと？
	Rcは複数所有権
	→なぜ？

